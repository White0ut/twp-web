import yaml

class ConfigParser:

  def __init__(self, config_file):
    # The dict keys in the gitolite yaml config
    self.REPOS_KEY = 'repos'
    self.GROUPS_KEY = 'groups'
    self.INCLUDES_KEY = 'includes'

    # open and load the config_file
    print 'Loading {0} ...'.format(config_file)
    self.config_file = config_file
    f = open(config_file, 'r')
    self.conf = yaml.load(f)
    f.close()
    print 'Loaded!'

    if not self.conf.has_key(self.REPOS_KEY):
      self.conf[self.REPOS_KEY] = {}
    if not self.conf.has_key(self.GROUPS_KEY):
      self.conf[self.GROUPS_KEY] = {}
    if not self.conf.has_key(self.INCLUDES_KEY):
      self.conf[self.INCLUDES_KEY] = {}

    self.repos = self.conf[self.REPOS_KEY]

  # removes an assignment from a course
  def remove_assignment(self, course, assignment):
    if self.repos.has_key[course] and self.repos[course].has_key(assignment):
      self.repos[course].pop(assignment)

  # creates an assignment from a course
  def create_assignment(self, course, assignment, opened = False):
    self.create_course(course)
    self.repos[course][assignment] = 'opened' if opened else 'closed'

  # removes a course
  def remove_course(self, course):
    if self.repos.has_key(course):
      self.repos.pop(course)
  
  # creates a course if one doesn't exist already
  def create_course(self, course):
    if course.__contains__(' '):
      raise KeyError('Invalid character in course name')
    if not self.repos.has_key(course):
      self.repos[course] = {}

  # update assignment
  def update_assignment(self, course, assignment, opened):
    self.repos[course][assignment] = 'opened' if opened else 'closed'

  # add a TA
  def add_ta(self, name):
    if not self.conf[self.GROUPS_KEY].has_key('TAs'):
      self.conf[self.GROUPS_KEY]['TAs'] = []
    tas = self.conf[self.GROUPS_KEY]['TAs']
    if not tas.__contains__(name):
      tas.append(name)

  #
  # dumps the config file to file
  #
  def dump(self, file_name, overwrite_yaml = True):
    print 'Dumping {0} to {1}'.format(self.conf, file_name)
    f = open(file_name, 'w')

    f.write('\
#\n\
# config file generated by config_parser.py, any modification will\n\
# be overriden. Please modify the associated yaml file!\n\
#\n\n')
    
    for k in self.conf[self.GROUPS_KEY].iterkeys():
      f.write('@{group} = {keys}'.format(group=k, \
          keys=' '.join(self.conf[self.GROUPS_KEY][k])))
      f.write('\n')
    f.write('\n')

    for course in self.repos.iterkeys():
      f.write('include "{course}.conf"\n'.format(course=course))
    f.write('\n')
    
    for _course in self.repos.iterkeys():
      for _assignment in self.repos[_course].iterkeys():
        assignment = str(_assignment)
        course = str(_course)
        # print 'course<{course}>:assignment<{assignment}>'.format(assignment=assignment,\
        #    course=course)

        self._write_template(f, course, assignment)
        if self.repos[_course][_assignment] == 'open':
          self._write_open(f, course, assignment)
        else:
          self._write_close(f, course, assignment)

    f.close()
    print 'Done!'

    if overwrite_yaml:
      self._dump_yaml()

  # Dumps the contents of the config back to the yaml file.
  # Updating any modifications
  def _dump_yaml(self):
    print 'Dumping back to yaml file: {0}'.format(self.config_file)
    config_f = open(self.config_file, 'w')
    config_f.write('\
#\n\
# Description file of the gitolite access rules\n\
# If you are editing this by hand please run the config_parser.py against\n\
# it to update the gitolite config.\n\
# It is recommended that you use the web interface!\n\
#\n\n')
    config_f.write(yaml.dump(self.conf))
    config_f.close()
    print 'Done!'
  
  def _write_template(self, f, course, assignment):
    f.write('\
repo {course}/{assignment}\n\
  C       =   @PROFs @TAs\n\
  RW+     =   @PROFS @TAs\n\
  R       =   @{course}\n\n'.format(course = course, assignment = assignment))

  def _write_open(self, f, course, assignment):
    f.write('\
repo {course}/CREATOR/[{assignment1}]{assignment2}\n\
  C       =   @PROFs @TAs @{course}\n\
  RW+     =   CREATOR @PROFs @TAs\n\n'\
          .format(course=course, assignment1=assignment[:1],\
            assignment2=assignment[1:]))

  def _write_close(self, f, course, assignment):
    f.write('\
repo {course}/CREATOR/[{assignment1}]{assignment2}\n\
  C       =   @PROFs @TAs\n\
  RW+     =   @PROFs @TAs\n\
  R       =   CREATOR\n\n'\
          .format(course=course, assignment1=assignment[:1],\
            assignment2=assignment[1:]))

